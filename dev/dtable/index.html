<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User guide · DTables.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliaparallel.github.io/DTables.jl/dtable/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DTables.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>User guide</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-DTable"><span>Creating a <code>DTable</code></span></a></li><li><a class="tocitem" href="#Underlying-table-type"><span>Underlying table type</span></a></li><li><a class="tocitem" href="#Behavior-of-the-interpartition_merges-kwarg"><span>Behavior of the <code>interpartition_merges</code> kwarg</span></a></li><li class="toplevel"><a class="tocitem" href="#Table-operations"><span>Table operations</span></a></li><li><a class="tocitem" href="#mapreduce-usage"><span><code>mapreduce</code> usage</span></a></li><li class="toplevel"><a class="tocitem" href="#DTables.groupby-interface"><span>DTables.groupby interface</span></a></li><li><a class="tocitem" href="#GDTable-operations"><span>GDTable operations</span></a></li><li><a class="tocitem" href="#Iterating-over-a-GDTable"><span>Iterating over a GDTable</span></a></li><li class="toplevel"><a class="tocitem" href="#Joins"><span>Joins</span></a></li><li class="toplevel"><a class="tocitem" href="#DataFrames.jl-minilanguage-and-operations-support-(experimental)"><span>DataFrames.jl minilanguage and operations support (experimental)</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/DTables.jl/blob/main/docs/src/dtable.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-guide"><a class="docs-heading-anchor" href="#User-guide">User guide</a><a id="User-guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-guide" title="Permalink"></a></h1><h2 id="Creating-a-DTable"><a class="docs-heading-anchor" href="#Creating-a-DTable">Creating a <code>DTable</code></a><a id="Creating-a-DTable-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-DTable" title="Permalink"></a></h2><p>There are currently two ways of constructing a distributed table:</p><h3 id="Tables.jl-source"><a class="docs-heading-anchor" href="#Tables.jl-source">Tables.jl source</a><a id="Tables.jl-source-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.jl-source" title="Permalink"></a></h3><p>Provide a <code>Tables.jl</code> compatible source, as well as a <code>chunksize</code>, which is the maximum number of rows of each partition:</p><pre><code class="language-julia hljs">julia&gt; using DTables

julia&gt; table = (a=[1, 2, 3, 4, 5], b=[6, 7, 8, 9, 10]);

julia&gt; d = DTable(table, 2)
DTable with 3 partitions
Tabletype: NamedTuple

julia&gt; fetch(d)
(a = [1, 2, 3, 4, 5], b = [6, 7, 8, 9, 10])</code></pre><h3 id="Loader-function-and-file-list"><a class="docs-heading-anchor" href="#Loader-function-and-file-list">Loader function and file list</a><a id="Loader-function-and-file-list-1"></a><a class="docs-heading-anchor-permalink" href="#Loader-function-and-file-list" title="Permalink"></a></h3><p>Provide a <code>loader_function</code> and a list of filenames, which are parts of the full table:</p><pre><code class="language-julia hljs">julia&gt; using DTables, CSV

julia&gt; files = [&quot;1.csv&quot;, &quot;2.csv&quot;, &quot;3.csv&quot;];

julia&gt; d = DTable(CSV.File, files)
DTable with 3 partitions
Tabletype: unknown (use `tabletype!(::DTable)`)

julia&gt; tabletype(d)
NamedTuple

julia&gt; fetch(d)
(a = [1, 2, 1, 2, 1, 2], b = [6, 7, 6, 7, 6, 7])</code></pre><h2 id="Underlying-table-type"><a class="docs-heading-anchor" href="#Underlying-table-type">Underlying table type</a><a id="Underlying-table-type-1"></a><a class="docs-heading-anchor-permalink" href="#Underlying-table-type" title="Permalink"></a></h2><p>The underlying type of the partition is, by default, of the type constructed by <code>Tables.materializer(source)</code>:</p><pre><code class="language-julia hljs">julia&gt; table = (a=[1, 2, 3, 4, 5], b=[6, 7, 8, 9, 10]);

julia&gt; d = DTable(table, 2)
DTable with 3 partitions
Tabletype: NamedTuple

julia&gt; fetch(d)
(a = [1, 2, 3, 4, 5], b = [6, 7, 8, 9, 10])</code></pre><p>To override the underlying type you can provide a kwarg <code>tabletype</code> to the <code>DTable</code> constructor.  You can also choose which tabletype the <code>DTable</code> should be fetched into:</p><pre><code class="language-julia hljs">julia&gt; using DataFrames

julia&gt; table = (a=[1, 2, 3, 4, 5], b=[6, 7, 8, 9, 10]);

julia&gt; d = DTable(table, 2; tabletype=DataFrame)
DTable with 3 partitions
Tabletype: DataFrame

julia&gt; fetch(d)
5×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      6
   2 │     2      7
   3 │     3      8
   4 │     4      9
   5 │     5     10

julia&gt; fetch(d, NamedTuple)
(a = [1, 2, 3, 4, 5], b = [6, 7, 8, 9, 10])</code></pre><h2 id="Behavior-of-the-interpartition_merges-kwarg"><a class="docs-heading-anchor" href="#Behavior-of-the-interpartition_merges-kwarg">Behavior of the <code>interpartition_merges</code> kwarg</a><a id="Behavior-of-the-interpartition_merges-kwarg-1"></a><a class="docs-heading-anchor-permalink" href="#Behavior-of-the-interpartition_merges-kwarg" title="Permalink"></a></h2><p>If a source supports the <code>Tables.partitions</code> interface then the DTable will assume the partitioning size from the source. However, if you decide to specify the exact size of the chunk the DTable will attempt to create chunks exactly of that size even if it means merging data between partitions. The behavior can be controlled by the <code>interpartition_merges</code> (<code>true</code> by default) kwarg and is best seen on the following example.</p><pre><code class="language-julia hljs">julia&gt; using DTables, CSV

julia&gt; DTable(CSV.Chunks(&quot;test.csv&quot;, ntasks=4)) |&gt; DTables.chunk_lengths
4-element Vector{Int64}:
 249995
 250005
 249995
 250005

julia&gt; DTable(CSV.Chunks(&quot;test.csv&quot;, ntasks=4), 200_000) |&gt; DTables.chunk_lengths
5-element Vector{Int64}:
 200000
 200000
 200000
 200000
 200000

julia&gt; DTable(CSV.Chunks(&quot;test.csv&quot;, ntasks=4), 200_000, interpartition_merges=false) |&gt; DTables.chunk_lengths
8-element Vector{Int64}:
 200000
  49995
 200000
  50005
 200000
  49995
 200000
  50005

julia&gt; DTable(CSV.Chunks(&quot;test.csv&quot;, ntasks=4), 300_000) |&gt; DTables.chunk_lengths
4-element Vector{Int64}:
 300000
 300000
 300000
 100000

julia&gt; DTable(CSV.Chunks(&quot;test.csv&quot;, ntasks=4), 300_000, interpartition_merges=false) |&gt; DTables.chunk_lengths
4-element Vector{Int64}:
 249995
 250005
 249995
 250005
</code></pre><h1 id="Table-operations"><a class="docs-heading-anchor" href="#Table-operations">Table operations</a><a id="Table-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Table-operations" title="Permalink"></a></h1><p><strong>Warning: this interface is experimental and may change at any time</strong></p><p>The current set of operations available consist of three simple functions: <code>map</code>, <code>filter</code> and <code>reduce</code>.</p><p>Below is an example of their usage.</p><p>For more information please refer to the API documentation and unit tests.</p><pre><code class="language-julia hljs">julia&gt; using DTables

julia&gt; d = DTable((k = repeat([&#39;a&#39;, &#39;b&#39;], 500), v = repeat(1:10, 100)), 100)
DTable with 10 partitions
Tabletype: NamedTuple

julia&gt; using DataFrames

julia&gt; m = map(x -&gt; (t = x.k + x.v, v = x.v), d)
DTable with 10 partitions
Tabletype: NamedTuple

julia&gt; fetch(m, DataFrame)
1000×2 DataFrame
  Row │ t     v
      │ Char  Int64
──────┼─────────────
    1 │ b         1
    2 │ d         2
    3 │ d         3
  ⋮   │  ⋮      ⋮
  999 │ j         9
 1000 │ l        10
    995 rows omitted

julia&gt; f = filter(x -&gt; x.t == &#39;d&#39;, m)
DTable with 10 partitions
Tabletype: NamedTuple

julia&gt; fetch(f, DataFrame)
200×2 DataFrame
 Row │ t     v
     │ Char  Int64
─────┼─────────────
   1 │ d         2
   2 │ d         3
  ⋮  │  ⋮      ⋮
 200 │ d         3
   197 rows omitted

julia&gt; r = reduce(+, m, cols=[:v])
EagerThunk (running)

julia&gt; fetch(r)
(v = 5500,)</code></pre><h2 id="mapreduce-usage"><a class="docs-heading-anchor" href="#mapreduce-usage"><code>mapreduce</code> usage</a><a id="mapreduce-usage-1"></a><a class="docs-heading-anchor-permalink" href="#mapreduce-usage" title="Permalink"></a></h2><p>The operation <code>mapreduce</code> is helpful in fully utilizing <code>OnlineStats</code>. It lets you transform a row to the required format before applying the reduce function. In consequence a lot of memory usage should be saved due to the lack of an intermediate <code>map</code> step that allocates a full column.</p><pre><code class="language-julia hljs">julia&gt; using DTables, OnlineStats

julia&gt; fetch(DTables.mapreduce(sum, fit!, d1, init = Mean()))
Mean: n=100 | value=1.50573

julia&gt; d1 = DTable((a=collect(1:100).%3, b=rand(100)), 25);

julia&gt; gg = GroupBy(Int, Mean());

julia&gt; fetch(DTables.mapreduce(x-&gt; (x.a, x.b), fit!, d1, init=gg))
GroupBy: Int64 =&gt; Mean
├─ 1
│  └─ Mean: n=34 | value=0.491379
├─ 2
│  └─ Mean: n=33 | value=0.555258
└─ 0
   └─ Mean: n=33 | value=0.470984

julia&gt; d2 = DTable((;a1=abs.(rand(Int, 100).%2), [Symbol(&quot;a\$(i)&quot;) =&gt; rand(100) for i in 2:3]...), 25);

julia&gt; gb = GroupBy(Int, Group([Series(Mean(), Variance(), Extrema()) for _ in 1:3]...));

julia&gt; fetch(DTables.mapreduce(r -&gt; (r.a1, tuple(r...)), fit!, d2, init = gb))
GroupBy: Int64 =&gt; Group
├─ 1
│  └─ Group
│     ├─ Series
│     │  ├─ Mean: n=57 | value=1.0
│     │  ├─ Variance: n=57 | value=0.0
│     │  └─ Extrema: n=57 | value=(min = 1.0, max = 1.0, nmin = 57, nmax = 57)
│     ├─ Series
│     │  ├─ Mean: n=57 | value=0.540256
│     │  ├─ Variance: n=57 | value=0.0767802
│     │  └─ Extrema: n=57 | value=(min = 0.0132545, max = 0.996059, nmin = 1, nmax = 1)
│     └─ Series
│        ├─ Mean: n=57 | value=0.536187
│        ├─ Variance: n=57 | value=0.0981499
│        └─ Extrema: n=57 | value=(min = 0.0112471, max = 0.991461, nmin = 1, nmax = 1)
└─ 0
   └─ Group
      ├─ Series
      │  ├─ Mean: n=43 | value=0.0
      │  ├─ Variance: n=43 | value=0.0
      │  └─ Extrema: n=43 | value=(min = 0.0, max = 0.0, nmin = 43, nmax = 43)
      ├─ Series
      │  ├─ Mean: n=43 | value=0.459732
      │  ├─ Variance: n=43 | value=0.0911548
      │  └─ Extrema: n=43 | value=(min = 0.000925526, max = 0.962072, nmin = 1, nmax = 1)
      └─ Series
         ├─ Mean: n=43 | value=0.490613
         ├─ Variance: n=43 | value=0.0850503
         └─ Extrema: n=43 | value=(min = 0.0450505, max = 0.981091, nmin = 1, nmax = 1)</code></pre><h1 id="DTables.groupby-interface"><a class="docs-heading-anchor" href="#DTables.groupby-interface">DTables.groupby interface</a><a id="DTables.groupby-interface-1"></a><a class="docs-heading-anchor-permalink" href="#DTables.groupby-interface" title="Permalink"></a></h1><p>A <code>DTable</code> can be grouped which will result in creation of a <code>GDTable</code>. A distinct set of values contained in a single or multiple columns can be used as grouping keys. If a transformation of a row needs to be performed in order to obtain the grouping key there&#39;s also an option to provide a custom function returning a key, which is applied per row.</p><p>The set of keys the <code>GDTable</code> is grouped by can be obtained using the <code>keys(gd::GDTable)</code> function. To get a fragment of the <code>GDTable</code> containing records belonging under a single key the <code>getindex(gd::GDTable, key)</code> function can be used.</p><pre><code class="language-julia hljs">julia&gt; d = DTable((a=shuffle(repeat(&#39;a&#39;:&#39;d&#39;, inner=4, outer=4)),b=repeat(1:4, 16)), 4)
DTable with 16 partitions
Tabletype: NamedTuple

julia&gt; DTables.groupby(d, :a)
GDTable with 4 partitions and 4 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; DTables.groupby(d, [:a, :b])
GDTable with 16 partitions and 16 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]

julia&gt; DTables.groupby(d, row -&gt; row.a + row.b)
GDTable with 7 partitions and 7 keys
Tabletype: NamedTuple
Grouped by: #5

julia&gt; g = DTables.groupby(d, :a); keys(g)
KeySet for a Dict{Char, Vector{UInt64}} with 4 entries. Keys:
  &#39;c&#39;
  &#39;d&#39;
  &#39;a&#39;
  &#39;b&#39;

julia&gt; g[&#39;c&#39;]
DTable with 1 partitions
Tabletype: NamedTuple</code></pre><h2 id="GDTable-operations"><a class="docs-heading-anchor" href="#GDTable-operations">GDTable operations</a><a id="GDTable-operations-1"></a><a class="docs-heading-anchor-permalink" href="#GDTable-operations" title="Permalink"></a></h2><p>Operations such as <code>map</code>, <code>filter</code>, <code>reduce</code> can be performed on a <code>GDTable</code></p><pre><code class="language-julia hljs">julia&gt; g = DTables.groupby(d, [:a, :b])
GDTable with 16 partitions and 16 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]

julia&gt; f = filter(x -&gt; x.a != &#39;d&#39;, g)
GDTable with 16 partitions and 16 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]

julia&gt; trim!(f)
GDTable with 12 partitions and 12 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]

julia&gt; m = map(r -&gt; (a = r.a, b = r.b, c = r.b .- 3), f)
GDTable with 12 partitions and 12 keys
Tabletype: NamedTuple
Grouped by: [:a, :b]

julia&gt; r = reduce(*, m)
EagerThunk (running)

julia&gt; DataFrame(fetch(r))
12×5 DataFrame
 Row │ a     b      result_a  result_b  result_c 
     │ Char  Int64  String    Int64     Int64    
─────┼───────────────────────────────────────────
   1 │ a         1  aaaa             1        16
   2 │ c         3  ccc             27         0
   3 │ a         3  aa               9         0
   4 │ b         4  bbbb           256         1
   5 │ c         4  cccc           256         1
   6 │ b         2  bbbb            16         1
   7 │ b         1  bbbb             1        16
   8 │ a         2  aaa              8        -1
   9 │ a         4  aaaaaaa      16384         1
  10 │ b         3  bbbb            81         0
  11 │ c         2  ccccc           32        -1
  12 │ c         1  cccc             1        16</code></pre><h2 id="Iterating-over-a-GDTable"><a class="docs-heading-anchor" href="#Iterating-over-a-GDTable">Iterating over a GDTable</a><a id="Iterating-over-a-GDTable-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-over-a-GDTable" title="Permalink"></a></h2><p><code>GDTable</code> can be iterated over and each element returned will be a pair of key and a <code>DTable</code> containing all rows associated with that grouping key.</p><pre><code class="language-julia hljs">julia&gt; d = DTable((a=repeat(&#39;a&#39;:&#39;b&#39;, inner=2),b=1:4), 2)
DTable with 2 partitions
Tabletype: NamedTuple

julia&gt; g = DTables.groupby(d, :a)
GDTable with 2 partitions and 2 keys
Tabletype: NamedTuple
Grouped by: [:a]

julia&gt; for (key, dt) in g
           println(&quot;Key: $key&quot;)
           println(fetch(dt, DataFrame))
       end
Key: a
2×2 DataFrame
 Row │ a     b     
     │ Char  Int64 
─────┼─────────────
   1 │ a         1
   2 │ a         2
Key: b
2×2 DataFrame
 Row │ a     b     
     │ Char  Int64 
─────┼─────────────
   1 │ b         3
   2 │ b         4</code></pre><h1 id="Joins"><a class="docs-heading-anchor" href="#Joins">Joins</a><a id="Joins-1"></a><a class="docs-heading-anchor-permalink" href="#Joins" title="Permalink"></a></h1><p>There are two join methods available currently: <code>leftjoin</code> and <code>innerjoin</code>. The interface is aiming to be compatible with the <code>DataFrames.jl</code> join interface, but for now it only supports the <code>on</code> keyword argument with symbol input. More keyword arguments known from <code>DataFrames</code> may be introduced in the future.</p><p>It&#39;s possible to perform a join on a <code>DTable</code> and any <code>Tables.jl</code> compatible table type. Joining two <code>DTable</code>s is also supported and it will leverage the fact that the second <code>DTable</code> is partitioned during the joining process.</p><p>There are several options to make your joins faster by providing additional information about the tables. It can be done by using the following keyword arguments:</p><ul><li><code>l_sorted</code>: To indicate the left table is sorted - only useful if the <code>r_sorted</code> is set to <code>true</code> as well.</li><li><code>r_sorted</code>: To indicate the right table is sorted.</li><li><code>r_unique</code>: To indicate the right table only contains unique keys.</li><li><code>lookup</code>: To provide a dict-like structure that will allow for quicker matching of inner rows. The structure needs to contain keys in form of a <code>Tuple</code> of the matched columns and values in form of type <code>Vector{UInt}</code> containing the related row indices.</li></ul><p>Currently there is a special case available where joining a <code>DTable</code> (with <code>DataFrame</code> as the underlying table type) with a <code>DataFrame</code> will use the join functions coming from the <code>DataFrames.jl</code> package for the per chunk joins. In the future this behavior will be expanded to any type that implements its own join methods, but for now is limited to <code>DataFrame</code> only.</p><p>Please note that the usage of any of the keyword arguments described above will always result in the usage of generic join methods defined in <code>DTables</code> regardless of the availability of specialized methods.</p><pre><code class="language-julia hljs">julia&gt; using Tables; pp = d -&gt; for x in Tables.rows(d) println(&quot;$(x.a), $(x.b), $(x.c)&quot;) end;

julia&gt; d1 = (a=collect(1:6), b=collect(1:6));

julia&gt; d2 = (a=collect(2:5), c=collect(-2:-1:-5));

julia&gt; dt = DTable(d1, 2)
DTable with 3 partitions
Tabletype: NamedTuple

julia&gt; pp(leftjoin(dt, d2, on=:a))
2, 2, -2
1, 1, missing
3, 3, -3
4, 4, -4
5, 5, -5
6, 6, missing

julia&gt; pp(innerjoin(dt, d2, on=:a))
2, 2, -2
3, 3, -3
4, 4, -4
5, 5, -5</code></pre><h1 id="DataFrames.jl-minilanguage-and-operations-support-(experimental)"><a class="docs-heading-anchor" href="#DataFrames.jl-minilanguage-and-operations-support-(experimental)">DataFrames.jl minilanguage and operations support (experimental)</a><a id="DataFrames.jl-minilanguage-and-operations-support-(experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#DataFrames.jl-minilanguage-and-operations-support-(experimental)" title="Permalink"></a></h1><p>Support for <code>DataFrames.jl</code> minilanguage and operations is planned for the <code>DTable</code> to enable a seemless transition between in-memory and distributed data processing.</p><p>As of today <code>select</code> is available with more operations to come in the future.</p><p>The goal is to provide exactly the same output as for DataFrames using the same <code>args</code>. Even though the output should be the same the DTable may require modification of user input in order to provide optimal distributed performance.</p><p>One already known tactic is to avoid functions that require access to the full column at once. The user should prefer to use <code>ByRow</code> equivalents or <code>reduce</code> instead. A complete performance guide will surely be a part of the documentation at some point.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 26 February 2023 11:03">Sunday 26 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
