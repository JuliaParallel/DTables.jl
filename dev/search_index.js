var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for DTables.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [DTables]","category":"page"},{"location":"api/#DTables.DTable","page":"API","title":"DTables.DTable","text":"DTable\n\nStructure representing the distributed table based on Dagger.\n\nThe table is stored as a vector of Chunk structures which hold partitions of the table. That vector can also store Dagger.EagerThunk structures when an operation that modifies the underlying partitions was applied to it (currently only filter).\n\n\n\n\n\n","category":"type"},{"location":"api/#DTables.DTable-Tuple{Any, Integer}","page":"API","title":"DTables.DTable","text":"DTable(table, chunksize; tabletype=nothing, interpartition_merges=true) -> DTable\n\nConstructs a DTable using a Tables.jl compatible table input. It assumes no initial partitioning of the table and uses the chunksize argument to partition the table (based on row count).\n\nProviding tabletype kwarg overrides the internal table partition type.\n\nUsing the interpartition_merges kwarg you can decide whether you want to opt out of merging rows between partitions. This option is enabled by default, which means it will prioritize creating chunks of the specified size even if it means taking rows from two or more partitions. When disabled there won't be any merges between partitions meaning several chunks can be smaller than expected due to shortage of rows within a partition. Please see tests for examples of behaviour.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.DTable-Tuple{Any}","page":"API","title":"DTables.DTable","text":"DTable(table; tabletype=nothing) -> DTable\n\nConstructs a DTable using a Tables.jl-compatible input table. Calls Tables.partitions on table and assumes the provided partitioning.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.DTable-Tuple{Function, Vector{String}}","page":"API","title":"DTables.DTable","text":"DTable(loader_function, files::Vector{String}; tabletype=nothing)\n\nConstructs a DTable using a list of filenames and a loader_function. Partitioning is based on the contents of the files provided, which means that one file is used to create one partition.\n\nProviding tabletype kwarg overrides the internal table partition type.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.GDTable","page":"API","title":"DTables.GDTable","text":"GDTable\n\nStructure representing a grouped DTable. It wraps over a DTable object and provides additional information on how the table is grouped. To represent the grouping a cols field is used, which contains the column symbols used for grouping and an index, which allows to effectively lookup the partitions grouped under a single key.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.fetch-Tuple{DTable, Any}","page":"API","title":"Base.fetch","text":"fetch(d::DTable, sink)\n\nCollects all the chunks in the DTable into a single, non-distributed instance of table type created using the provided sink function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.fetch-Tuple{DTable}","page":"API","title":"Base.fetch","text":"fetch(d::DTable)\n\nCollects all the chunks in the DTable into a single, non-distributed instance of the underlying table type.\n\nFetching an empty DTable results in returning an empty NamedTuple regardless of the underlying tabletype.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.filter-Tuple{Any, DTables.GDTable}","page":"API","title":"Base.filter","text":"filter(f, gd::GDTable) -> GDTable\n\nFilter 'gd' using 'f', returning a filtered GDTable. Calling trim! on a filtered GDTable will clean up the empty keys and partitions.\n\nExamples\n\njulia> g = DTables.groupby(DTable((a=repeat('a':'d', inner=2),b=1:8), 2), :a)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> f = filter(x -> x.a ∈ ['a', 'b'], g)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> fetch(f)\n(a = ['a', 'a', 'b', 'b'], b = [1, 2, 3, 4])\n\njulia> trim!(f)\nGDTable with 2 partitions and 2 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.filter-Tuple{Any, DTable}","page":"API","title":"Base.filter","text":"filter(f, d::DTable) -> DTable\n\nFilter d using f. Returns a filtered DTable that can be processed further.\n\nExamples\n\njulia> d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);\n\njulia> f = filter(x -> x.a < 3, d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(f)\n(a = [1, 2], b = [1, 1])\n\njulia> f = filter(x -> (x.a < 3) .& (x.b > 0), d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(f)\n(a = [1, 2], b = [1, 1])\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DTables.GDTable, Any}","page":"API","title":"Base.getindex","text":"getindex(gdt::GDTable, key) -> DTable\n\nRetrieves a DTable from gdt with rows belonging to the provided grouping key.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.keys-Tuple{DTables.GDTable}","page":"API","title":"Base.keys","text":"keys(gd::GDTable) -> KeySet\n\nReturns the keys that gd is grouped by.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.map-Tuple{Any, DTables.GDTable}","page":"API","title":"Base.map","text":"map(f, gd::GDTable) -> GDTable\n\nApplies f to each row of gd. The applied function needs to return a Tables.Row compatible object (e.g. NamedTuple).\n\nExamples\n\njulia> g = DTables.groupby(DTable((a=repeat('a':'c', inner=2),b=1:6), 2), :a)\nGDTable with 3 partitions and 3 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> m = map(r -> (a = r.a, b = r.b, c = r.a + r.b), g)\nGDTable with 3 partitions and 3 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> fetch(m)\n(a = ['a', 'a', 'c', 'c', 'b', 'b'], b = [1, 2, 5, 6, 3, 4], c = ['b', 'c', 'h', 'i', 'e', 'f'])\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.map-Tuple{Any, DTable}","page":"API","title":"Base.map","text":"map(f, d::DTable) -> DTable\n\nApplies f to each row of d. The applied function needs to return a Tables.Row compatible object (e.g. NamedTuple).\n\nExamples\n\njulia> d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);\n\njulia> m = map(x -> (r = x.a + x.b,), d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(m)\n(r = [2, 3, 4],)\n\njulia> m = map(x -> (r1 = x.a + x.b, r2 = x.a - x.b), d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(m)\n(r1 = [2, 3, 4], r2 = [0, 1, 2])\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.reduce-Tuple{Any, DTables.GDTable}","page":"API","title":"Base.reduce","text":"reduce(f, gd::GDTable; cols=nothing, prefix=\"result_\", [init]) -> Dagger.EagerThunk -> NamedTuple\n\nReduces gd using function f applied on all columns of the DTable. Returns results per group in columns with names prefixed with the prefix kwarg. For more information on kwargs see reduce(f, d::DTable)\n\nExamples\n\njulia> g = DTables.groupby(DTable((a=repeat('a':'d', inner=2),b=1:8), 2), :a)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> fetch(reduce(*, g))\n(a = ['a', 'c', 'd', 'b'], result_a = [\"aa\", \"cc\", \"dd\", \"bb\"], result_b = [2, 30, 56, 12])\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.reduce-Tuple{Any, DTable}","page":"API","title":"Base.reduce","text":"reduce(f, d::DTable; cols=nothing, [init]) -> NamedTuple\n\nReduces d using function f applied on all columns of the DTable.\n\nBy providing the kwarg cols as a Vector{Symbol} object it's possible to restrict the reduction to the specified columns. The reduced values are provided in a NamedTuple under names of reduced columns.\n\nFor the init kwarg please refer to Base.reduce documentation, as it follows the same principles.\n\nExamples\n\njulia> d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);\n\njulia> r1 = reduce(+, d)\nDagger.EagerThunk (running)\n\njulia> fetch(r1)\n(a = 6, b = 3)\n\njulia> r2 = reduce(*, d, cols=[:a])\nDagger.EagerThunk (running)\n\njulia> fetch(r2)\n(a = 6,)\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables._groupby-Tuple{DTable, Function, Union{Nothing, Vector{Symbol}}, Bool, Int64}","page":"API","title":"DTables._groupby","text":"_groupby(d::DTable, row_function::Function, cols::Union{Nothing, Vector{Symbol}}, merge::Bool, chunksize::Int)\n\nInternal function for performing the groupby steps based on common arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables._join-Tuple{Symbol, Any, Any}","page":"API","title":"DTables._join","text":"_join(type::Symbol, l_chunk, r; kwargs...)\n\nLow level join method for DTable joins using the generic implementation. It joins an l_chunk with r assuming r is a continuous table.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables._join-Tuple{Symbol, Any, DTable}","page":"API","title":"DTables._join","text":"_join(type::Symbol, l_chunk, r::DTable; kwargs...)\n\nLow level join method for DTable joins using the generic implementation. It joins an l_chunk with r assuming r is a DTable. In this case the join is split into multiple joins of l_chunk with each chunk of r and a final merge operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.build_groupby_index-Tuple{Bool, Int64, Any, Any}","page":"API","title":"DTables.build_groupby_index","text":"build_groupby_index(merge::Bool, chunksize::Int, tabletype, vs...)\n\nTakes the intermediate result of distinct_partitions and builds an index. Merges partitions if possible according to the chunksize provided. It will only merge chunks if their length after merging is <= chunksize. It doesn't split chunks larger than chunksize and small chunks may be leftover after merging if no appropriate pair was found.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.build_joined_table-Tuple{Symbol, Tuple, Any, Any, Vector{UInt64}, Vector{UInt64}, Set{UInt64}, Tuple{Vararg{T, N}} where {N, T}}","page":"API","title":"DTables.build_joined_table","text":"build_joined_table(jointype, names, l, r, inner_l, inner_r, outer_l, other_r)\n\nTakes the indices of matching rows (inner*) and the ones that weren't matched (outer_l) from the l table and builds the result based on that.\n\nUses all the columns from the left column and the other_r columns from the right table.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.distinct_partitions-Tuple{Any, Function}","page":"API","title":"DTables.distinct_partitions","text":"distinct_partitions(chunk, f::Function)\n\nTakes a partition and groups its rows according based on the key value returned by f.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.find_outer_indices-Tuple{Any, Any}","page":"API","title":"DTables.find_outer_indices","text":"find_outer_indices(d, inner_indices)\n\nFinds the unmatched indices from the table.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.groupby-Tuple{DTable, Function}","page":"API","title":"DTables.groupby","text":"groupby(d::DTable, f::Function; merge=true, chunksize=0)\n\nGroups d by the distinct set of keys created by applying f to each row in d.\n\nFor kwargs usage details see groupby(d::DTable, col::Symbol)\n\njulia> d = DTable((a=shuffle(repeat('a':'d', inner=4, outer=4)),b=repeat(1:4, 16)), 4)\nDTable with 16 partitions\nTabletype: NamedTuple\n\njulia> function group_fun(row)\n           row.a + row.b\n       end\ngroup_fun (generic function with 1 method)\n\njulia> DTables.groupby(d, group_fun)\nGDTable with 7 partitions and 7 keys\nTabletype: NamedTuple\nGrouped by: group_fun\n\njulia> DTables.groupby(d, row -> row.a + row.b, chunksize=3)\nGDTable with 25 partitions and 7 keys\nTabletype: NamedTuple\nGrouped by: group_fun\n\njulia> DTables.groupby(d, row -> row.a + row.b, merge=false)\nGDTable with 52 partitions and 7 keys\nTabletype: NamedTuple\nGrouped by: group_fun\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.groupby-Tuple{DTable, Symbol}","page":"API","title":"DTables.groupby","text":"groupby(d::DTable, col::Symbol; merge=true, chunksize=0) -> GDTable\n\nGroups d by distinct values of column col.\n\nThe process of grouping can be affected by providing kwargs merge and chunksize. By default all the chunks belonging to a single key will be merged into a single partition. Providing a positive value in chunksize will attempt to merge the smaller partitions into partitions not bigger than chunksize. Please note that partitions bigger than chunksize will not be split into partitions of chunksize. Merging can be disabled completely by providing merge=false.\n\nExamples\n\njulia> d = DTable((a=shuffle(repeat('a':'d', inner=4, outer=4)),), 4)\nDTable with 16 partitions\nTabletype: NamedTuple\n\njulia> DTables.groupby(d, :a)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> DTables.groupby(d, :a, chunksize=3)\nGDTable with 24 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> DTables.groupby(d, :a, merge=false)\nGDTable with 42 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.groupby-Tuple{DTable, Vector{Symbol}}","page":"API","title":"DTables.groupby","text":"groupby(d::DTable, cols::Vector{Symbol}; merge=true, chunksize=0)\n\nGroups the d by distinct values of columns cols. The key is constructed by creating a NamedTuple from each row based on cols provided.\n\nFor kwargs usage details see groupby(d::DTable, col::Symbol)\n\nExamples\n\njulia> d = DTable((a=shuffle(repeat('a':'d', inner=4, outer=4)),b=repeat(1:4, 16)), 4)\nDTable with 16 partitions\nTabletype: NamedTuple\n\njulia> DTables.groupby(d, [:a,:b])\nGDTable with 16 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> DTables.groupby(d, [:a,:b], chunksize=3)\nGDTable with 27 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> DTables.groupby(d, [:a,:b], merge=false)\nGDTable with 64 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.grouped_cols-Tuple{DTables.GDTable}","page":"API","title":"DTables.grouped_cols","text":"grouped_cols(gd::GDTable) -> Vector{Symbol}\n\nReturns the symbols of columns used in the grouping. In case grouping on a function was performed a :KEYS symbol will be returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.match_inner_indices-NTuple{8, Any}","page":"API","title":"DTables.match_inner_indices","text":"match_inner_indices(l, r, cmp_l, cmp_r, lookup, r_sorted, l_sorted, r_unique)\n\nFunction responsible for picking the optimal method of joining inner indices depending on the additional information about the tables provided by the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.match_inner_indices-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"API","title":"DTables.match_inner_indices","text":"match_inner_indices(l, r, l_ind::NTuple{N,Int}, r_ind::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Standard non-optimized use case.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.match_inner_indices_lookup-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}}} where N","page":"API","title":"DTables.match_inner_indices_lookup","text":"match_inner_indices_lookup(l, lookup, l_ind::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Uses lookup to find the matching indices.\n\nlookup needs to be a dict-like structure that contains keys in form of a Tuple of all matching columns and values in form of type Vector{UInt} containing the related row indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.match_inner_indices_lsorted_rsorted-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, Bool}} where N","page":"API","title":"DTables.match_inner_indices_lsorted_rsorted","text":"match_inner_indices_lsorted_rsorted(l, r, cmp_l::NTuple{N,Int}, cmp_r::NTuple{N,Int}, runique::Bool)\n\nReturns two vectors containing indices of matched rows. Optimized pass for the left table sorted, right table sorted and optionally right table only containing unique keys.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.match_inner_indices_rsorted-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"API","title":"DTables.match_inner_indices_rsorted","text":"match_inner_indices_rsorted(l, r, cmp_l::NTuple{N,Int}, cmp_r::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Optimized pass for joins with a sorted right table.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.match_inner_indices_runique-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"API","title":"DTables.match_inner_indices_runique","text":"match_inner_indices_runique(l, r, cmp_l::NTuple{N,Int}, cmp_r::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Optimized pass for joins with the right table containing unique keys only.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.select-Tuple{DTable, Vararg{Any}}","page":"API","title":"DTables.select","text":"select(df::DTable, args...; copycols::Bool=true, renamecols::Bool=true)\n\nCreate a new DTable that contains columns from df specified by args and return it. The result is guaranteed to have the same number of rows as df, except when no columns are selected (in which case the result has zero rows).\n\nThis operation is supposed to provide the same functionality and syntax as DataFrames.select, but for DTable input. Most cases should be covered and the output should be exactly the same as one obtained using DataFrames. In case of output differences or args causing errors please file an issue with reproduction steps and data.\n\nPlease refer to DataFrames documentation for more details on usage.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.tabletype!-Tuple{DTables.GDTable}","page":"API","title":"DTables.tabletype!","text":"tabletype!(gd::GDTable)\n\nProvides the type of the underlying table partition and caches it in gd.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.tabletype!-Tuple{DTable}","page":"API","title":"DTables.tabletype!","text":"tabletype!(d::DTable)\n\nProvides the type of the underlying table partition and caches it in d.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.tabletype-Tuple{DTables.GDTable}","page":"API","title":"DTables.tabletype","text":"tabletype(gd::GDTable)\n\nProvides the type of the underlying table partition. Uses the cached tabletype if available.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.tabletype-Tuple{DTable}","page":"API","title":"DTables.tabletype","text":"tabletype(d::DTable)\n\nProvides the type of the underlying table partition. Uses the cached tabletype if available.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.trim!-Tuple{DTables.GDTable}","page":"API","title":"DTables.trim!","text":"trim!(gd::GDTable) -> GDTable\n\nRemoves empty chunks from gd and unused keys from its index.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.trim!-Tuple{DTable}","page":"API","title":"DTables.trim!","text":"trim!(d::DTable) -> DTable\n\nRemoves empty chunks from d.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.trim-Tuple{DTables.GDTable}","page":"API","title":"DTables.trim","text":"trim(gd::GDTable) -> GDTable\n\nReturns gd with empty chunks and keys removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.trim-Tuple{DTable}","page":"API","title":"DTables.trim","text":"trim(d::DTable) -> DTable\n\nReturns d with empty chunks removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#DTables.use_dataframe_join-Tuple{Any, Any}","page":"API","title":"DTables.use_dataframe_join","text":"use_dataframe_join(d1type, d2type)\n\nDetermines whether to use the DataAPI join function, which leads to usage of DataFrames join function if both types are DataFrame. Remove this function and it's usage once a generic Tables.jl compatible join function becomes available. Porting the Dagger join functions to TableOperations is an option to achieve that.\n\n\n\n\n\n","category":"method"},{"location":"api/#DataAPI.innerjoin-Tuple{DTable, Any}","page":"API","title":"DataAPI.innerjoin","text":"innerjoin(d1::DTable, d2; on=nothing, l_sorted=false, r_sorted=false, r_unique=false, lookup=nothing)\n\nPerform an inner join of d1 with any Tables.jl compatible table type. Returns a DTable with the result.\n\nIf the underlying table type happens to have a innerjoin implementation and none of the below DTable related kwargs will be provided the specialized function will be used. A good example of that is calling innerjoin on a DTable with a DataFrame underlying type and a d2 of DataFrame type.\n\nKeyword arguments\n\non: Column symbols to join on. Can be provided as a symbol or a pair of symbols in case the column names differ. For joins on multiple columns a vector of the previously mentioned can be provided.\nl_sorted: To indicate the left table is sorted - only useful if the r_sorted is set to true as well.\nr_sorted: To indicate the right table is sorted.\nr_unique: To indicate the right table only contains unique keys.\nlookup: To provide a dict-like structure that will allow for direct matching of inner rows. The structure needs to contain keys in form of a Tuple and values in form of type Vector{UInt} containing the related row indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#DataAPI.leftjoin-Tuple{DTable, Any}","page":"API","title":"DataAPI.leftjoin","text":"leftjoin(d1::DTable, d2; on=nothing, l_sorted=false, r_sorted=false, r_unique=false, lookup=nothing)\n\nPerform a left join of d1 with any Tables.jl compatible table type. Returns a DTable with the result.\n\nIf the underlying table type happens to have a leftjoin implementation and none of the below DTable related kwargs will be provided the specialized function will be used. A good example of that is calling leftjoin on a DTable with a DataFrame underlying type and a d2 of DataFrame type.\n\nKeyword arguments\n\non: Column symbols to join on. Can be provided as a symbol or a pair of symbols in case the column names differ. For joins on multiple columns a vector of the previously mentioned can be provided.\nl_sorted: To indicate the left table is sorted - only useful if the r_sorted is set to true as well.\nr_sorted: To indicate the right table is sorted.\nr_unique: To indicate the right table only contains unique keys.\nlookup: To provide a dict-like structure that will allow for direct matching of inner rows. The structure needs to contain keys in form of a Tuple and values in form of type Vector{UInt} containing the related row indices.\n\n\n\n\n\n","category":"method"},{"location":"dtable/#User-guide","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"dtable/#Creating-a-DTable","page":"User guide","title":"Creating a DTable","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"There are currently two ways of constructing a distributed table:","category":"page"},{"location":"dtable/#Tables.jl-source","page":"User guide","title":"Tables.jl source","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Provide a Tables.jl compatible source, as well as a chunksize, which is the maximum number of rows of each partition:","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> using DTables\n\njulia> table = (a=[1, 2, 3, 4, 5], b=[6, 7, 8, 9, 10]);\n\njulia> d = DTable(table, 2)\nDTable with 3 partitions\nTabletype: NamedTuple\n\njulia> fetch(d)\n(a = [1, 2, 3, 4, 5], b = [6, 7, 8, 9, 10])","category":"page"},{"location":"dtable/#Loader-function-and-file-list","page":"User guide","title":"Loader function and file list","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Provide a loader_function and a list of filenames, which are parts of the full table:","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> using DTables, CSV\n\njulia> files = [\"1.csv\", \"2.csv\", \"3.csv\"];\n\njulia> d = DTable(CSV.File, files)\nDTable with 3 partitions\nTabletype: unknown (use `tabletype!(::DTable)`)\n\njulia> tabletype(d)\nNamedTuple\n\njulia> fetch(d)\n(a = [1, 2, 1, 2, 1, 2], b = [6, 7, 6, 7, 6, 7])","category":"page"},{"location":"dtable/#Underlying-table-type","page":"User guide","title":"Underlying table type","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"The underlying type of the partition is, by default, of the type constructed by Tables.materializer(source):","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> table = (a=[1, 2, 3, 4, 5], b=[6, 7, 8, 9, 10]);\n\njulia> d = DTable(table, 2)\nDTable with 3 partitions\nTabletype: NamedTuple\n\njulia> fetch(d)\n(a = [1, 2, 3, 4, 5], b = [6, 7, 8, 9, 10])","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"To override the underlying type you can provide a kwarg tabletype to the DTable constructor.  You can also choose which tabletype the DTable should be fetched into:","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> using DataFrames\n\njulia> table = (a=[1, 2, 3, 4, 5], b=[6, 7, 8, 9, 10]);\n\njulia> d = DTable(table, 2; tabletype=DataFrame)\nDTable with 3 partitions\nTabletype: DataFrame\n\njulia> fetch(d)\n5×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      6\n   2 │     2      7\n   3 │     3      8\n   4 │     4      9\n   5 │     5     10\n\njulia> fetch(d, NamedTuple)\n(a = [1, 2, 3, 4, 5], b = [6, 7, 8, 9, 10])","category":"page"},{"location":"dtable/#Behavior-of-the-interpartition_merges-kwarg","page":"User guide","title":"Behavior of the interpartition_merges kwarg","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"If a source supports the Tables.partitions interface then the DTable will assume the partitioning size from the source. However, if you decide to specify the exact size of the chunk the DTable will attempt to create chunks exactly of that size even if it means merging data between partitions. The behavior can be controlled by the interpartition_merges (true by default) kwarg and is best seen on the following example.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> using DTables, CSV\n\njulia> DTable(CSV.Chunks(\"test.csv\", ntasks=4)) |> DTables.chunk_lengths\n4-element Vector{Int64}:\n 249995\n 250005\n 249995\n 250005\n\njulia> DTable(CSV.Chunks(\"test.csv\", ntasks=4), 200_000) |> DTables.chunk_lengths\n5-element Vector{Int64}:\n 200000\n 200000\n 200000\n 200000\n 200000\n\njulia> DTable(CSV.Chunks(\"test.csv\", ntasks=4), 200_000, interpartition_merges=false) |> DTables.chunk_lengths\n8-element Vector{Int64}:\n 200000\n  49995\n 200000\n  50005\n 200000\n  49995\n 200000\n  50005\n\njulia> DTable(CSV.Chunks(\"test.csv\", ntasks=4), 300_000) |> DTables.chunk_lengths\n4-element Vector{Int64}:\n 300000\n 300000\n 300000\n 100000\n\njulia> DTable(CSV.Chunks(\"test.csv\", ntasks=4), 300_000, interpartition_merges=false) |> DTables.chunk_lengths\n4-element Vector{Int64}:\n 249995\n 250005\n 249995\n 250005\n","category":"page"},{"location":"dtable/#Table-operations","page":"User guide","title":"Table operations","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Warning: this interface is experimental and may change at any time","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"The current set of operations available consist of three simple functions: map, filter and reduce.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Below is an example of their usage.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"For more information please refer to the API documentation and unit tests.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> using DTables\n\njulia> d = DTable((k = repeat(['a', 'b'], 500), v = repeat(1:10, 100)), 100)\nDTable with 10 partitions\nTabletype: NamedTuple\n\njulia> using DataFrames\n\njulia> m = map(x -> (t = x.k + x.v, v = x.v), d)\nDTable with 10 partitions\nTabletype: NamedTuple\n\njulia> fetch(m, DataFrame)\n1000×2 DataFrame\n  Row │ t     v\n      │ Char  Int64\n──────┼─────────────\n    1 │ b         1\n    2 │ d         2\n    3 │ d         3\n  ⋮   │  ⋮      ⋮\n  999 │ j         9\n 1000 │ l        10\n    995 rows omitted\n\njulia> f = filter(x -> x.t == 'd', m)\nDTable with 10 partitions\nTabletype: NamedTuple\n\njulia> fetch(f, DataFrame)\n200×2 DataFrame\n Row │ t     v\n     │ Char  Int64\n─────┼─────────────\n   1 │ d         2\n   2 │ d         3\n  ⋮  │  ⋮      ⋮\n 200 │ d         3\n   197 rows omitted\n\njulia> r = reduce(+, m, cols=[:v])\nEagerThunk (running)\n\njulia> fetch(r)\n(v = 5500,)","category":"page"},{"location":"dtable/#mapreduce-usage","page":"User guide","title":"mapreduce usage","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"The operation mapreduce is helpful in fully utilizing OnlineStats. It lets you transform a row to the required format before applying the reduce function. In consequence a lot of memory usage should be saved due to the lack of an intermediate map step that allocates a full column.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> using DTables, OnlineStats\n\njulia> fetch(DTables.mapreduce(sum, fit!, d1, init = Mean()))\nMean: n=100 | value=1.50573\n\njulia> d1 = DTable((a=collect(1:100).%3, b=rand(100)), 25);\n\njulia> gg = GroupBy(Int, Mean());\n\njulia> fetch(DTables.mapreduce(x-> (x.a, x.b), fit!, d1, init=gg))\nGroupBy: Int64 => Mean\n├─ 1\n│  └─ Mean: n=34 | value=0.491379\n├─ 2\n│  └─ Mean: n=33 | value=0.555258\n└─ 0\n   └─ Mean: n=33 | value=0.470984\n\njulia> d2 = DTable((;a1=abs.(rand(Int, 100).%2), [Symbol(\"a\\$(i)\") => rand(100) for i in 2:3]...), 25);\n\njulia> gb = GroupBy(Int, Group([Series(Mean(), Variance(), Extrema()) for _ in 1:3]...));\n\njulia> fetch(DTables.mapreduce(r -> (r.a1, tuple(r...)), fit!, d2, init = gb))\nGroupBy: Int64 => Group\n├─ 1\n│  └─ Group\n│     ├─ Series\n│     │  ├─ Mean: n=57 | value=1.0\n│     │  ├─ Variance: n=57 | value=0.0\n│     │  └─ Extrema: n=57 | value=(min = 1.0, max = 1.0, nmin = 57, nmax = 57)\n│     ├─ Series\n│     │  ├─ Mean: n=57 | value=0.540256\n│     │  ├─ Variance: n=57 | value=0.0767802\n│     │  └─ Extrema: n=57 | value=(min = 0.0132545, max = 0.996059, nmin = 1, nmax = 1)\n│     └─ Series\n│        ├─ Mean: n=57 | value=0.536187\n│        ├─ Variance: n=57 | value=0.0981499\n│        └─ Extrema: n=57 | value=(min = 0.0112471, max = 0.991461, nmin = 1, nmax = 1)\n└─ 0\n   └─ Group\n      ├─ Series\n      │  ├─ Mean: n=43 | value=0.0\n      │  ├─ Variance: n=43 | value=0.0\n      │  └─ Extrema: n=43 | value=(min = 0.0, max = 0.0, nmin = 43, nmax = 43)\n      ├─ Series\n      │  ├─ Mean: n=43 | value=0.459732\n      │  ├─ Variance: n=43 | value=0.0911548\n      │  └─ Extrema: n=43 | value=(min = 0.000925526, max = 0.962072, nmin = 1, nmax = 1)\n      └─ Series\n         ├─ Mean: n=43 | value=0.490613\n         ├─ Variance: n=43 | value=0.0850503\n         └─ Extrema: n=43 | value=(min = 0.0450505, max = 0.981091, nmin = 1, nmax = 1)","category":"page"},{"location":"dtable/#DTables.groupby-interface","page":"User guide","title":"DTables.groupby interface","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"A DTable can be grouped which will result in creation of a GDTable. A distinct set of values contained in a single or multiple columns can be used as grouping keys. If a transformation of a row needs to be performed in order to obtain the grouping key there's also an option to provide a custom function returning a key, which is applied per row.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"The set of keys the GDTable is grouped by can be obtained using the keys(gd::GDTable) function. To get a fragment of the GDTable containing records belonging under a single key the getindex(gd::GDTable, key) function can be used.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> d = DTable((a=shuffle(repeat('a':'d', inner=4, outer=4)),b=repeat(1:4, 16)), 4)\nDTable with 16 partitions\nTabletype: NamedTuple\n\njulia> DTables.groupby(d, :a)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> DTables.groupby(d, [:a, :b])\nGDTable with 16 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> DTables.groupby(d, row -> row.a + row.b)\nGDTable with 7 partitions and 7 keys\nTabletype: NamedTuple\nGrouped by: #5\n\njulia> g = DTables.groupby(d, :a); keys(g)\nKeySet for a Dict{Char, Vector{UInt64}} with 4 entries. Keys:\n  'c'\n  'd'\n  'a'\n  'b'\n\njulia> g['c']\nDTable with 1 partitions\nTabletype: NamedTuple","category":"page"},{"location":"dtable/#GDTable-operations","page":"User guide","title":"GDTable operations","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Operations such as map, filter, reduce can be performed on a GDTable","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> g = DTables.groupby(d, [:a, :b])\nGDTable with 16 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> f = filter(x -> x.a != 'd', g)\nGDTable with 16 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> trim!(f)\nGDTable with 12 partitions and 12 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> m = map(r -> (a = r.a, b = r.b, c = r.b .- 3), f)\nGDTable with 12 partitions and 12 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> r = reduce(*, m)\nEagerThunk (running)\n\njulia> DataFrame(fetch(r))\n12×5 DataFrame\n Row │ a     b      result_a  result_b  result_c \n     │ Char  Int64  String    Int64     Int64    \n─────┼───────────────────────────────────────────\n   1 │ a         1  aaaa             1        16\n   2 │ c         3  ccc             27         0\n   3 │ a         3  aa               9         0\n   4 │ b         4  bbbb           256         1\n   5 │ c         4  cccc           256         1\n   6 │ b         2  bbbb            16         1\n   7 │ b         1  bbbb             1        16\n   8 │ a         2  aaa              8        -1\n   9 │ a         4  aaaaaaa      16384         1\n  10 │ b         3  bbbb            81         0\n  11 │ c         2  ccccc           32        -1\n  12 │ c         1  cccc             1        16","category":"page"},{"location":"dtable/#Iterating-over-a-GDTable","page":"User guide","title":"Iterating over a GDTable","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"GDTable can be iterated over and each element returned will be a pair of key and a DTable containing all rows associated with that grouping key.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> d = DTable((a=repeat('a':'b', inner=2),b=1:4), 2)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> g = DTables.groupby(d, :a)\nGDTable with 2 partitions and 2 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> for (key, dt) in g\n           println(\"Key: $key\")\n           println(fetch(dt, DataFrame))\n       end\nKey: a\n2×2 DataFrame\n Row │ a     b     \n     │ Char  Int64 \n─────┼─────────────\n   1 │ a         1\n   2 │ a         2\nKey: b\n2×2 DataFrame\n Row │ a     b     \n     │ Char  Int64 \n─────┼─────────────\n   1 │ b         3\n   2 │ b         4","category":"page"},{"location":"dtable/#Joins","page":"User guide","title":"Joins","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"There are two join methods available currently: leftjoin and innerjoin. The interface is aiming to be compatible with the DataFrames.jl join interface, but for now it only supports the on keyword argument with symbol input. More keyword arguments known from DataFrames may be introduced in the future.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"It's possible to perform a join on a DTable and any Tables.jl compatible table type. Joining two DTables is also supported and it will leverage the fact that the second DTable is partitioned during the joining process.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"There are several options to make your joins faster by providing additional information about the tables. It can be done by using the following keyword arguments:","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"l_sorted: To indicate the left table is sorted - only useful if the r_sorted is set to true as well.\nr_sorted: To indicate the right table is sorted.\nr_unique: To indicate the right table only contains unique keys.\nlookup: To provide a dict-like structure that will allow for quicker matching of inner rows. The structure needs to contain keys in form of a Tuple of the matched columns and values in form of type Vector{UInt} containing the related row indices.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Currently there is a special case available where joining a DTable (with DataFrame as the underlying table type) with a DataFrame will use the join functions coming from the DataFrames.jl package for the per chunk joins. In the future this behavior will be expanded to any type that implements its own join methods, but for now is limited to DataFrame only.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Please note that the usage of any of the keyword arguments described above will always result in the usage of generic join methods defined in DTables regardless of the availability of specialized methods.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"julia> using Tables; pp = d -> for x in Tables.rows(d) println(\"$(x.a), $(x.b), $(x.c)\") end;\n\njulia> d1 = (a=collect(1:6), b=collect(1:6));\n\njulia> d2 = (a=collect(2:5), c=collect(-2:-1:-5));\n\njulia> dt = DTable(d1, 2)\nDTable with 3 partitions\nTabletype: NamedTuple\n\njulia> pp(leftjoin(dt, d2, on=:a))\n2, 2, -2\n1, 1, missing\n3, 3, -3\n4, 4, -4\n5, 5, -5\n6, 6, missing\n\njulia> pp(innerjoin(dt, d2, on=:a))\n2, 2, -2\n3, 3, -3\n4, 4, -4\n5, 5, -5","category":"page"},{"location":"dtable/#DataFrames.jl-minilanguage-and-operations-support-(experimental)","page":"User guide","title":"DataFrames.jl minilanguage and operations support (experimental)","text":"","category":"section"},{"location":"dtable/","page":"User guide","title":"User guide","text":"Support for DataFrames.jl minilanguage and operations is planned for the DTable to enable a seemless transition between in-memory and distributed data processing.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"As of today select is available with more operations to come in the future.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"The goal is to provide exactly the same output as for DataFrames using the same args. Even though the output should be the same the DTable may require modification of user input in order to provide optimal distributed performance.","category":"page"},{"location":"dtable/","page":"User guide","title":"User guide","text":"One already known tactic is to avoid functions that require access to the full column at once. The user should prefer to use ByRow equivalents or reduce instead. A complete performance guide will surely be a part of the documentation at some point.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DTables","category":"page"},{"location":"#Distributed-table","page":"Home","title":"Distributed table","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The DTable, or \"distributed table\", is an abstraction layer on top of Dagger that allows loading table-like structures into a distributed environment.  The main idea is that a Tables.jl-compatible source provided by the user gets partitioned into several parts and stored as Chunks.  These can then be distributed across worker processes by the scheduler as operations are performed on the containing DTable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Operations performed on a DTable leverage the fact that the table is partitioned, and will try to apply functions per-partition first, afterwards merging the results if needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The distributed table is backed by Dagger's Eager API (Dagger.@spawn and Dagger.spawn).  To provide a familiar usage pattern you can call fetch on a DTable instance, which returns an in-memory instance of the underlying table type (such as a DataFrame, TypedTable, etc).","category":"page"}]
}
