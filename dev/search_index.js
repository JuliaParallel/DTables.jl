var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DTables","category":"page"},{"location":"#DTables","page":"Home","title":"DTables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DTables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DTables]","category":"page"},{"location":"#DTables.DTable","page":"Home","title":"DTables.DTable","text":"DTable\n\nStructure representing the distributed table based on Dagger.\n\nThe table is stored as a vector of Chunk structures which hold partitions of the table. That vector can also store Dagger.EagerThunk structures when an operation that modifies the underlying partitions was applied to it (currently only filter).\n\n\n\n\n\n","category":"type"},{"location":"#DTables.DTable-Tuple{Any, Integer}","page":"Home","title":"DTables.DTable","text":"DTable(table, chunksize; tabletype=nothing) -> DTable\n\nConstructs a DTable using a Tables.jl compatible table input. It assumes no initial partitioning of the table and uses the chunksize argument to partition the table (based on row count).\n\nProviding tabletype kwarg overrides the internal table partition type.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.DTable-Tuple{Any, Vector{String}}","page":"Home","title":"DTables.DTable","text":"DTable(loader_function, files::Vector{String}; tabletype=nothing)\n\nConstructs a DTable using a list of filenames and a loader_function. Partitioning is based on the contents of the files provided, which means that one file is used to create one partition.\n\nProviding tabletype kwarg overrides the internal table partition type.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.DTable-Tuple{Any}","page":"Home","title":"DTables.DTable","text":"DTable(table; tabletype=nothing) -> DTable\n\nConstructs a DTable using a Tables.jl-compatible input table. Calls Tables.partitions on table and assumes the provided partitioning.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.GDTable","page":"Home","title":"DTables.GDTable","text":"GDTable\n\nStructure representing a grouped DTable. It wraps over a DTable object and provides additional information on how the table is grouped. To represent the grouping a cols field is used, which contains the column symbols used for grouping and an index, which allows to effectively lookup the partitions grouped under a single key.\n\n\n\n\n\n","category":"type"},{"location":"#Base.fetch-Tuple{DTable, Any}","page":"Home","title":"Base.fetch","text":"fetch(d::DTable, sink)\n\nCollects all the chunks in the DTable into a single, non-distributed instance of table type created using the provided sink function.\n\n\n\n\n\n","category":"method"},{"location":"#Base.fetch-Tuple{DTable}","page":"Home","title":"Base.fetch","text":"fetch(d::DTable)\n\nCollects all the chunks in the DTable into a single, non-distributed instance of the underlying table type.\n\nFetching an empty DTable results in returning an empty NamedTuple regardless of the underlying tabletype.\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Any, DTables.GDTable}","page":"Home","title":"Base.filter","text":"filter(f, gd::GDTable) -> GDTable\n\nFilter 'gd' using 'f', returning a filtered GDTable. Calling trim! on a filtered GDTable will clean up the empty keys and partitions.\n\nExamples\n\njulia> g = DTables.groupby(DTable((a=repeat('a':'d', inner=2),b=1:8), 2), :a)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> f = filter(x -> x.a âˆˆ ['a', 'b'], g)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> fetch(f)\n(a = ['a', 'a', 'b', 'b'], b = [1, 2, 3, 4])\n\njulia> trim!(f)\nGDTable with 2 partitions and 2 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Any, DTable}","page":"Home","title":"Base.filter","text":"filter(f, d::DTable) -> DTable\n\nFilter d using f. Returns a filtered DTable that can be processed further.\n\nExamples\n\njulia> d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);\n\njulia> f = filter(x -> x.a < 3, d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(f)\n(a = [1, 2], b = [1, 1])\n\njulia> f = filter(x -> (x.a < 3) .& (x.b > 0), d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(f)\n(a = [1, 2], b = [1, 1])\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{DTables.GDTable, Any}","page":"Home","title":"Base.getindex","text":"getindex(gdt::GDTable, key) -> DTable\n\nRetrieves a DTable from gdt with rows belonging to the provided grouping key.\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{DTables.GDTable}","page":"Home","title":"Base.keys","text":"keys(gd::GDTable) -> KeySet\n\nReturns the keys that gd is grouped by.\n\n\n\n\n\n","category":"method"},{"location":"#Base.map-Tuple{Any, DTables.GDTable}","page":"Home","title":"Base.map","text":"map(f, gd::GDTable) -> GDTable\n\nApplies f to each row of gd. The applied function needs to return a Tables.Row compatible object (e.g. NamedTuple).\n\nExamples\n\njulia> g = DTables.groupby(DTable((a=repeat('a':'c', inner=2),b=1:6), 2), :a)\nGDTable with 3 partitions and 3 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> m = map(r -> (a = r.a, b = r.b, c = r.a + r.b), g)\nGDTable with 3 partitions and 3 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> fetch(m)\n(a = ['a', 'a', 'c', 'c', 'b', 'b'], b = [1, 2, 5, 6, 3, 4], c = ['b', 'c', 'h', 'i', 'e', 'f'])\n\n\n\n\n\n","category":"method"},{"location":"#Base.map-Tuple{Any, DTable}","page":"Home","title":"Base.map","text":"map(f, d::DTable) -> DTable\n\nApplies f to each row of d. The applied function needs to return a Tables.Row compatible object (e.g. NamedTuple).\n\nExamples\n\njulia> d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);\n\njulia> m = map(x -> (r = x.a + x.b,), d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(m)\n(r = [2, 3, 4],)\n\njulia> m = map(x -> (r1 = x.a + x.b, r2 = x.a - x.b), d)\nDTable with 2 partitions\nTabletype: NamedTuple\n\njulia> fetch(m)\n(r1 = [2, 3, 4], r2 = [0, 1, 2])\n\n\n\n\n\n","category":"method"},{"location":"#Base.reduce-Tuple{Any, DTables.GDTable}","page":"Home","title":"Base.reduce","text":"reduce(f, gd::GDTable; cols=nothing, prefix=\"result_\", [init]) -> Dagger.EagerThunk -> NamedTuple\n\nReduces gd using function f applied on all columns of the DTable. Returns results per group in columns with names prefixed with the prefix kwarg. For more information on kwargs see reduce(f, d::DTable)\n\nExamples\n\njulia> g = DTables.groupby(DTable((a=repeat('a':'d', inner=2),b=1:8), 2), :a)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> fetch(reduce(*, g))\n(a = ['a', 'c', 'd', 'b'], result_a = [\"aa\", \"cc\", \"dd\", \"bb\"], result_b = [2, 30, 56, 12])\n\n\n\n\n\n","category":"method"},{"location":"#Base.reduce-Tuple{Any, DTable}","page":"Home","title":"Base.reduce","text":"reduce(f, d::DTable; cols=nothing, [init]) -> NamedTuple\n\nReduces d using function f applied on all columns of the DTable.\n\nBy providing the kwarg cols as a Vector{Symbol} object it's possible to restrict the reduction to the specified columns. The reduced values are provided in a NamedTuple under names of reduced columns.\n\nFor the init kwarg please refer to Base.reduce documentation, as it follows the same principles.\n\nExamples\n\njulia> d = DTable((a = [1, 2, 3], b = [1, 1, 1]), 2);\n\njulia> r1 = reduce(+, d)\nDagger.EagerThunk (running)\n\njulia> fetch(r1)\n(a = 6, b = 3)\n\njulia> r2 = reduce(*, d, cols=[:a])\nDagger.EagerThunk (running)\n\njulia> fetch(r2)\n(a = 6,)\n\n\n\n\n\n","category":"method"},{"location":"#DTables._groupby-Tuple{DTable, Function, Union{Nothing, Vector{Symbol}}, Bool, Int64}","page":"Home","title":"DTables._groupby","text":"_groupby(d::DTable, row_function::Function, cols::Union{Nothing, Vector{Symbol}}, merge::Bool, chunksize::Int)\n\nInternal function for performing the groupby steps based on common arguments.\n\n\n\n\n\n","category":"method"},{"location":"#DTables._join-Tuple{Symbol, Any, Any}","page":"Home","title":"DTables._join","text":"_join(type::Symbol, l_chunk, r; kwargs...)\n\nLow level join method for DTable joins using the generic implementation. It joins an l_chunk with r assuming r is a continuous table.\n\n\n\n\n\n","category":"method"},{"location":"#DTables._join-Tuple{Symbol, Any, DTable}","page":"Home","title":"DTables._join","text":"_join(type::Symbol, l_chunk, r::DTable; kwargs...)\n\nLow level join method for DTable joins using the generic implementation. It joins an l_chunk with r assuming r is a DTable. In this case the join is split into multiple joins of l_chunk with each chunk of r and a final merge operation.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.build_groupby_index-Tuple{Bool, Int64, Any, Any}","page":"Home","title":"DTables.build_groupby_index","text":"build_groupby_index(merge::Bool, chunksize::Int, tabletype, vs...)\n\nTakes the intermediate result of distinct_partitions and builds an index. Merges partitions if possible according to the chunksize provided. It will only merge chunks if their length after merging is <= chunksize. It doesn't split chunks larger than chunksize and small chunks may be leftover after merging if no appropriate pair was found.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.build_joined_table-Tuple{Symbol, Tuple, Any, Any, Vector{UInt64}, Vector{UInt64}, Set{UInt64}, Tuple{Vararg{T, N}} where {N, T}}","page":"Home","title":"DTables.build_joined_table","text":"build_joined_table(jointype, names, l, r, inner_l, inner_r, outer_l, other_r)\n\nTakes the indices of matching rows (inner*) and the ones that weren't matched (outer_l) from the l table and builds the result based on that.\n\nUses all the columns from the left column and the other_r columns from the right table.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.distinct_partitions-Tuple{Any, Function}","page":"Home","title":"DTables.distinct_partitions","text":"distinct_partitions(chunk, f::Function)\n\nTakes a partition and groups its rows according based on the key value returned by f.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.find_outer_indices-Tuple{Any, Any}","page":"Home","title":"DTables.find_outer_indices","text":"find_outer_indices(d, inner_indices)\n\nFinds the unmatched indices from the table.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.groupby-Tuple{DTable, Function}","page":"Home","title":"DTables.groupby","text":"groupby(d::DTable, f::Function; merge=true, chunksize=0)\n\nGroups d by the distinct set of keys created by applying f to each row in d.\n\nFor kwargs usage details see groupby(d::DTable, col::Symbol)\n\njulia> d = DTable((a=shuffle(repeat('a':'d', inner=4, outer=4)),b=repeat(1:4, 16)), 4)\nDTable with 16 partitions\nTabletype: NamedTuple\n\njulia> function group_fun(row)\n           row.a + row.b\n       end\ngroup_fun (generic function with 1 method)\n\njulia> DTables.groupby(d, group_fun)\nGDTable with 7 partitions and 7 keys\nTabletype: NamedTuple\nGrouped by: group_fun\n\njulia> DTables.groupby(d, row -> row.a + row.b, chunksize=3)\nGDTable with 25 partitions and 7 keys\nTabletype: NamedTuple\nGrouped by: group_fun\n\njulia> DTables.groupby(d, row -> row.a + row.b, merge=false)\nGDTable with 52 partitions and 7 keys\nTabletype: NamedTuple\nGrouped by: group_fun\n\n\n\n\n\n","category":"method"},{"location":"#DTables.groupby-Tuple{DTable, Symbol}","page":"Home","title":"DTables.groupby","text":"groupby(d::DTable, col::Symbol; merge=true, chunksize=0) -> GDTable\n\nGroups d by distinct values of column col.\n\nThe process of grouping can be affected by providing kwargs merge and chunksize. By default all the chunks belonging to a single key will be merged into a single partition. Providing a positive value in chunksize will attempt to merge the smaller partitions into partitions not bigger than chunksize. Please note that partitions bigger than chunksize will not be split into partitions of chunksize. Merging can be disabled completely by providing merge=false.\n\nExamples\n\njulia> d = DTable((a=shuffle(repeat('a':'d', inner=4, outer=4)),), 4)\nDTable with 16 partitions\nTabletype: NamedTuple\n\njulia> DTables.groupby(d, :a)\nGDTable with 4 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> DTables.groupby(d, :a, chunksize=3)\nGDTable with 24 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\njulia> DTables.groupby(d, :a, merge=false)\nGDTable with 42 partitions and 4 keys\nTabletype: NamedTuple\nGrouped by: [:a]\n\n\n\n\n\n","category":"method"},{"location":"#DTables.groupby-Tuple{DTable, Vector{Symbol}}","page":"Home","title":"DTables.groupby","text":"groupby(d::DTable, cols::Vector{Symbol}; merge=true, chunksize=0)\n\nGroups the d by distinct values of columns cols. The key is constructed by creating a NamedTuple from each row based on cols provided.\n\nFor kwargs usage details see groupby(d::DTable, col::Symbol)\n\nExamples\n\njulia> d = DTable((a=shuffle(repeat('a':'d', inner=4, outer=4)),b=repeat(1:4, 16)), 4)\nDTable with 16 partitions\nTabletype: NamedTuple\n\njulia> DTables.groupby(d, [:a,:b])\nGDTable with 16 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> DTables.groupby(d, [:a,:b], chunksize=3)\nGDTable with 27 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\njulia> DTables.groupby(d, [:a,:b], merge=false)\nGDTable with 64 partitions and 16 keys\nTabletype: NamedTuple\nGrouped by: [:a, :b]\n\n\n\n\n\n","category":"method"},{"location":"#DTables.grouped_cols-Tuple{DTables.GDTable}","page":"Home","title":"DTables.grouped_cols","text":"grouped_cols(gd::GDTable) -> Vector{Symbol}\n\nReturns the symbols of columns used in the grouping. In case grouping on a function was performed a :KEYS symbol will be returned.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.match_inner_indices-NTuple{8, Any}","page":"Home","title":"DTables.match_inner_indices","text":"match_inner_indices(l, r, cmp_l, cmp_r, lookup, r_sorted, l_sorted, r_unique)\n\nFunction responsible for picking the optimal method of joining inner indices depending on the additional information about the tables provided by the user.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.match_inner_indices-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"Home","title":"DTables.match_inner_indices","text":"match_inner_indices(l, r, l_ind::NTuple{N,Int}, r_ind::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Standard non-optimized use case.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.match_inner_indices_lookup-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}}} where N","page":"Home","title":"DTables.match_inner_indices_lookup","text":"match_inner_indices_lookup(l, lookup, l_ind::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Uses lookup to find the matching indices.\n\nlookup needs to be a dict-like structure that contains keys in form of a Tuple of all matching columns and values in form of type Vector{UInt} containing the related row indices.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.match_inner_indices_lsorted_rsorted-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, Bool}} where N","page":"Home","title":"DTables.match_inner_indices_lsorted_rsorted","text":"match_inner_indices_lsorted_rsorted(l, r, cmp_l::NTuple{N,Int}, cmp_r::NTuple{N,Int}, runique::Bool)\n\nReturns two vectors containing indices of matched rows. Optimized pass for the left table sorted, right table sorted and optionally right table only containing unique keys.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.match_inner_indices_rsorted-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"Home","title":"DTables.match_inner_indices_rsorted","text":"match_inner_indices_rsorted(l, r, cmp_l::NTuple{N,Int}, cmp_r::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Optimized pass for joins with a sorted right table.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.match_inner_indices_runique-Union{Tuple{N}, Tuple{Any, Any, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}}} where N","page":"Home","title":"DTables.match_inner_indices_runique","text":"match_inner_indices_runique(l, r, cmp_l::NTuple{N,Int}, cmp_r::NTuple{N,Int})\n\nReturns two vectors containing indices of matched rows. Optimized pass for joins with the right table containing unique keys only.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.select-Tuple{DTable, Vararg{Any}}","page":"Home","title":"DTables.select","text":"select(df::DTable, args...; copycols::Bool=true, renamecols::Bool=true)\n\nCreate a new DTable that contains columns from df specified by args and return it. The result is guaranteed to have the same number of rows as df, except when no columns are selected (in which case the result has zero rows).\n\nThis operation is supposed to provide the same functionality and syntax as DataFrames.select, but for DTable input. Most cases should be covered and the output should be exactly the same as one obtained using DataFrames. In case of output differences or args causing errors please file an issue with reproduction steps and data.\n\nPlease refer to DataFrames documentation for more details on usage.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.tabletype!-Tuple{DTables.GDTable}","page":"Home","title":"DTables.tabletype!","text":"tabletype!(gd::GDTable)\n\nProvides the type of the underlying table partition and caches it in gd.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.tabletype!-Tuple{DTable}","page":"Home","title":"DTables.tabletype!","text":"tabletype!(d::DTable)\n\nProvides the type of the underlying table partition and caches it in d.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.tabletype-Tuple{DTables.GDTable}","page":"Home","title":"DTables.tabletype","text":"tabletype(gd::GDTable)\n\nProvides the type of the underlying table partition. Uses the cached tabletype if available.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.tabletype-Tuple{DTable}","page":"Home","title":"DTables.tabletype","text":"tabletype(d::DTable)\n\nProvides the type of the underlying table partition. Uses the cached tabletype if available.\n\nIn case the tabletype cannot be obtained the default return value is NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.trim!-Tuple{DTables.GDTable}","page":"Home","title":"DTables.trim!","text":"trim!(gd::GDTable) -> GDTable\n\nRemoves empty chunks from gd and unused keys from its index.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.trim!-Tuple{DTable}","page":"Home","title":"DTables.trim!","text":"trim!(d::DTable) -> DTable\n\nRemoves empty chunks from d.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.trim-Tuple{DTables.GDTable}","page":"Home","title":"DTables.trim","text":"trim(gd::GDTable) -> GDTable\n\nReturns gd with empty chunks and keys removed.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.trim-Tuple{DTable}","page":"Home","title":"DTables.trim","text":"trim(d::DTable) -> DTable\n\nReturns d with empty chunks removed.\n\n\n\n\n\n","category":"method"},{"location":"#DTables.use_dataframe_join-Tuple{Any, Any}","page":"Home","title":"DTables.use_dataframe_join","text":"use_dataframe_join(d1type, d2type)\n\nDetermines whether to use the DataAPI join function, which leads to usage of DataFrames join function if both types are DataFrame. Remove this function and it's usage once a generic Tables.jl compatible join function becomes available. Porting the Dagger join functions to TableOperations is an option to achieve that.\n\n\n\n\n\n","category":"method"},{"location":"#DataAPI.innerjoin-Tuple{DTable, Any}","page":"Home","title":"DataAPI.innerjoin","text":"innerjoin(d1::DTable, d2; on=nothing, l_sorted=false, r_sorted=false, r_unique=false, lookup=nothing)\n\nPerform an inner join of d1 with any Tables.jl compatible table type. Returns a DTable with the result.\n\nIf the underlying table type happens to have a innerjoin implementation and none of the below DTable related kwargs will be provided the specialized function will be used. A good example of that is calling innerjoin on a DTable with a DataFrame underlying type and a d2 of DataFrame type.\n\nKeyword arguments\n\non: Column symbols to join on. Can be provided as a symbol or a pair of symbols in case the column names differ. For joins on multiple columns a vector of the previously mentioned can be provided.\nl_sorted: To indicate the left table is sorted - only useful if the r_sorted is set to true as well.\nr_sorted: To indicate the right table is sorted.\nr_unique: To indicate the right table only contains unique keys.\nlookup: To provide a dict-like structure that will allow for direct matching of inner rows. The structure needs to contain keys in form of a Tuple and values in form of type Vector{UInt} containing the related row indices.\n\n\n\n\n\n","category":"method"},{"location":"#DataAPI.leftjoin-Tuple{DTable, Any}","page":"Home","title":"DataAPI.leftjoin","text":"leftjoin(d1::DTable, d2; on=nothing, l_sorted=false, r_sorted=false, r_unique=false, lookup=nothing)\n\nPerform a left join of d1 with any Tables.jl compatible table type. Returns a DTable with the result.\n\nIf the underlying table type happens to have a leftjoin implementation and none of the below DTable related kwargs will be provided the specialized function will be used. A good example of that is calling leftjoin on a DTable with a DataFrame underlying type and a d2 of DataFrame type.\n\nKeyword arguments\n\non: Column symbols to join on. Can be provided as a symbol or a pair of symbols in case the column names differ. For joins on multiple columns a vector of the previously mentioned can be provided.\nl_sorted: To indicate the left table is sorted - only useful if the r_sorted is set to true as well.\nr_sorted: To indicate the right table is sorted.\nr_unique: To indicate the right table only contains unique keys.\nlookup: To provide a dict-like structure that will allow for direct matching of inner rows. The structure needs to contain keys in form of a Tuple and values in form of type Vector{UInt} containing the related row indices.\n\n\n\n\n\n","category":"method"}]
}
